# ECMAScript 5

## 数据类型

在 ES5 规范中，JavaScript 有 6 种数据类型，它们分别是：

- 数值，number
- 布尔值，boolean
- 字符串，string
- 两个特殊类型，null 和 undefined
- 对象，object，对象可以细分为三种子类型
  - 狭义的对象，object
  - 函数，function
  - 数字，array

### 数值

#### 概述

**整数和浮点数**

JavaScript 内部，所有数字都是以 64 位浮点数形式储存，即使整数也是如此。所以，`1` 与 `1.0` 是相同的，是同一个数。

```js
1 === 1.0 // true
```

也就是说，JavaScript 语言的底层根本没有整数，所以数字都是小数（64 位浮点数）。容易造成混淆的是，某些运算只有整数才能完成，此时 JavaScript 会自动把 64 位浮点数，转成 32 位整数，然后再进行运算。

由于浮点数不是精确的值，所以涉及小数的比较和运算要特别小心。

```js
0.1 + 0.2 === 0.3
// false

0.3 / 0.1
// 2.9999999999999996

(0.3 - 0.2) === (0.2 - 0.1)
// false
```

**数值精度**

根据国际标准 IEEE 754，JavaScript 浮点数的64个二进制位，从最左边开始，是这样组成的。

- 第 1 位：符号位，`0` 表示正数，`1` 表示负数
- 第 2 位到第 12 位（共 11 位）：指数部分
- 第 13 位到第 64 位（共 52 位）：小数部分（即有效数字）

符号位决定了一个数的正负，指数部分决定了数值的大小，小数部分决定了数值的精度。

指数部分一共有 11 个二进制位，因此大小范围就是 0 到 2047。IEEE 754 规定，如果指数部分的值在 0 到 2047 之间（不含两个端点），那么有效数字的第一位默认总是1，不保存在64位浮点数之中。也就是说，有效数字这时总是 `1.xx...xx` 的形式，其中 `xx..xx` 的部分保存在 64 位浮点数之中，最长可能为 52 位。因此，JavaScript 提供的有效数字最长为 53 个二进制位。

```js
(-1)^符号位 * 1.xx...xx * 2^指数部分
```

精度最多只能到53个二进制位，这意味着，绝对值小于 2 的 53 次方的整数，即 $-2^{53}$ 到 $2^{53}$，都可以精确表示。

```js
Math.pow(2, 53)
// 9007199254740992

Math.pow(2, 53) + 1
// 9007199254740992

Math.pow(2, 53) + 2
// 9007199254740994

Math.pow(2, 53) + 3
// 9007199254740996

Math.pow(2, 53) + 4
// 9007199254740996
```

由于 2 的 53 次方是一个 16 位的十进制数字，所以简单的法则就是，JavaScript 对 15 位的十进制数都可以精确处理。

**数值范围**

根据标准，64 位浮点数的指数部分的长度是 11 个二进制位，意味着指数部分的最大值是 2047（2 的 11 次方减 1）。也就是说，64 位浮点数的指数部分的值最大为 2047，分出一半表示负数，则 JavaScript 能表示的数值范围为 $2^{1024}$ 到 $2^{-1023}$ （开区间），超出这个范围的值无法表示。

如果一个数大于等于2的1024次方，那么就会发生“正向溢出”，即 JavaScript 无法表示这么大的数，这时就会返回`Infinity`。

```js
Math.pow(2, 1024); // Infinity
```

如果一个数小于等于 2 的 -1075 次方（指数部分最小值 -2013，再加上小数部分的 52 位），那么就会发生为 “负向溢出”，即 JavaScript 无法表示这么小的数，这时会直接返回 0。

```js
Math.pow(2, -1075); // 0
```

### 

## 参考

- [阮一峰 JavaScript 教程](https://www.bookstack.cn/read/javascript-tutorial/README.md)